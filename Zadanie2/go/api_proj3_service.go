// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * MIMUW ISBD database system
 *
 * This file describes interface between DBMS system and user.
 *
 * API version: 1.0.0
 */

package openapi

import (
	"Zadanie2/metastore"
	"context"
	"errors"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
)

func convertTypeToLogical(t metastore.ColumnType) LogicalColumnType {
    switch t {
    case metastore.TypeString:
		return VARCHAR
	case metastore.TypeInt:
		return INT64
	default:
		panic("unknown column type")
	}
}

func convertTypeFromLogical(t LogicalColumnType) (metastore.ColumnType, error) {
    switch t {
    case VARCHAR:
		return metastore.TypeString, nil
	case INT64:
		return metastore.TypeInt, nil
	default:
		return 0, errors.New("unknown column type")
	}
}

func convertColumns(cols []metastore.Column) []Column {
    out := make([]Column, len(cols))
    for i, c := range cols {
        out[i] = Column{
            Name: c.Name,
            Type: convertTypeToLogical(c.Type),
        }
    }
    return out
}

type Proj3APIService struct {
    ms *metastore.Metastore
    qs *queryStore
	si *SystemInfo
	scheduler *QueryScheduler
}

func NewProj3APIService(ms *metastore.Metastore) *Proj3APIService {
	qs := newQueryStore()
	scheduler := NewQueryScheduler(ms, qs, 4, "data")
	scheduler.Start()
	return &Proj3APIService{ms: ms, qs: qs, si: NewSystemInfo("1.0.1", "1", "Krzysztof Å»yndul"), scheduler: scheduler}
}

func (s *Proj3APIService) Shutdown() {
	s.scheduler.Stop()
}

func (s *Proj3APIService) GetTables(ctx context.Context) (ImplResponse, error) {
    tables := s.ms.ListTables()
    shallow := make([]ShallowTable, len(tables))
    for i, t := range tables {
        shallow[i] = ShallowTable{TableId: t.ID, Name: t.Name}
    }
    return Response(http.StatusOK, shallow), nil
}

func (s *Proj3APIService) GetTableById(
	ctx context.Context,
	tableId string,
) (ImplResponse, error) {
    t, err := s.ms.GetTableById(tableId)
    if err != nil {
        return Response(http.StatusNotFound, Error{Message: err.Error()}), nil
    }

	columns := make([]metastore.Column, 0, len(t.Columns))
	for _, col := range t.Columns {
		columns = append(columns, col)
	}

    schema := TableSchema{
        Name:    t.Name,
        Columns: convertColumns(columns),
    }
    return Response(http.StatusOK, schema), nil
}

func (s *Proj3APIService) DeleteTable(ctx context.Context, tableId string) (ImplResponse, error) {
	if _, err := s.ms.GetTableById(tableId); err != nil {
		return Response(http.StatusNotFound, Error{Message: err.Error()}), nil
	}

	iq := &internalQuery{
		ID: uuid.NewString(),
		QueryDefinition: QueryQueryDefinition{
			TableName: tableId,
		},
		Status:            CREATED,
		IsResultAvailable: false,
		IsSelect:          false,
		IsDelete:          true,
		Submitted:         time.Now(),
		Started:           nil,
		Finished:          nil,
		Error:             nil,
		ResultRows:        QueryResultInner{},
		doneChan:          make(chan struct{}),
	}

	s.qs.add(iq)
	// log.Println("Submitting delete table query", iq.string())
	s.scheduler.SubmitQuery(iq.ID)

	// Wait for completion
	<-iq.doneChan
	
	if iq.GetStatus() == FAILED {
		return Response(http.StatusInternalServerError, Error{
			Message: "Deletion failed",
		}), nil
	}
	return Response(http.StatusOK, "Table deleted"), nil
}
// TODO has to create empty fiels
func (s *Proj3APIService) CreateTable(
	ctx context.Context,
	tableSchema TableSchema,
) (ImplResponse, error) {
    name := tableSchema.Name

    cols := make([]metastore.Column, len(tableSchema.Columns))
    for i, c := range tableSchema.Columns {
        logicalType, err := convertTypeFromLogical(c.Type)
        if err != nil {
            return Response(http.StatusBadRequest, fmt.Sprintf("Invalid column type for column '%s': %v", c.Name, err)), nil
        }
        cols[i] = metastore.Column{
            Name: c.Name,
            Type: logicalType,
        }
    }

	tableID, err := s.ms.CreateTable(name, cols, name)
	if err != nil {
		return Response(http.StatusBadRequest, fmt.Sprintf("failed to create table '%s': %v", name, err)), nil
	}
    return Response(http.StatusOK, tableID), nil
}

func (s *Proj3APIService) GetQueries(ctx context.Context) (ImplResponse, error) {
    items := s.qs.list()
    out := make([]ShallowQuery, len(items))
    for i, iq := range items {
        out[i] = toShallow(iq)
    }
    return Response(http.StatusOK, out), nil
}

func (s *Proj3APIService) GetQueryById(
	ctx context.Context,
	queryId string,
) (ImplResponse, error) {
    iq, ok := s.qs.get(queryId)
    if !ok {
        return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
    }
    return Response(http.StatusOK, toPublic(iq)), nil
}

func (s *Proj3APIService) SubmitQuery(
	ctx context.Context,
	executeQueryRequest ExecuteQueryRequest,
) (ImplResponse, error) {

	qd := executeQueryRequest.QueryDefinition

	isSelect := qd.TableName != ""
	isLoad := qd.SourceFilepath != "" && qd.DestinationTableName != ""
		// TODO add validation of query 400 Cannot create query due to problems in request (or e.g. table in query doesn't exist)

	if !isSelect && !isLoad {
		return Response(
			http.StatusBadRequest,
			"Invalid query definition: either TableName for SELECT or SourceFilepath and DestinationTableName for LOAD must be provided",
		), nil
	}

	iq := &internalQuery{
		ID:                uuid.NewString(),
		QueryDefinition:   qd,
		Status:            CREATED,
		IsResultAvailable: false,
		IsSelect:          isSelect,
		IsDelete:          false,
		Submitted:         time.Now(),
		Started:           nil,
		Finished:          nil,
		Error:             nil,
		ResultRows:        QueryResultInner{},
	}

	s.qs.add(iq)
	s.scheduler.SubmitQuery(iq.ID)

	return Response(
		http.StatusOK,
		iq.ID,
	), nil
}

func (s *Proj3APIService) GetQueryResult(ctx context.Context, queryId string, getQueryResultRequest GetQueryResultRequest) (ImplResponse, error) {
	iq, ok := s.qs.get(queryId)
	if !ok {
		return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
	}

	if !iq.IsSelect {
		return Response(http.StatusBadRequest, Error{Message: "Result of this query is not available"}), nil
	}

	if !iq.GetIsResultAvailable() {
		return Response(http.StatusBadRequest, Error{Message: "Result of this query is not available"}), nil
	}

	resultRows := iq.GetResultRows()
	var result QueryResultInner = resultRows
	
	if getQueryResultRequest.RowLimit > 0 {
		limit := int(getQueryResultRequest.RowLimit)

		if limit > int(resultRows.RowCount) {
			limit = int(resultRows.RowCount)
		}

		result.Columns = make([]QueryResultInnerColumnsInner, len(resultRows.Columns))
		for i := range resultRows.Columns {
			if len(resultRows.Columns[i]) > limit {
				result.Columns[i] = resultRows.Columns[i][:limit]
			} else {
				result.Columns[i] = resultRows.Columns[i]
			}
		}

		result.RowCount = int32(limit)
	}

	if getQueryResultRequest.FlushResult {
		iq.ClearResult()
	}

	return Response(http.StatusOK, result), nil
}

func (s *Proj3APIService) GetQueryError(ctx context.Context, queryId string) (ImplResponse, error) {

	iq, ok := s.qs.get(queryId)
	if !ok {
		return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
	}

	if iq.GetStatus() != FAILED {
		return Response(http.StatusBadRequest, Error{Message: "Error for this query is not available"}), nil
	}

	return Response(http.StatusOK, iq.GetError()), nil
}

func (s *Proj3APIService) GetSystemInfo(ctx context.Context) (ImplResponse, error) {
	sysInfo := s.si

	return Response(http.StatusOK, SystemInformation{
		InterfaceVersion: sysInfo.InterfaceVersion,
		Version:          sysInfo.Version,
		Author:           sysInfo.Author,
		Uptime:           sysInfo.UptimeSeconds(),
	}), nil
}