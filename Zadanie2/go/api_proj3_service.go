// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * MIMUW ISBD database system
 *
 * This file describes interface between DBMS system and user.
 *
 * API version: 1.0.0
 */

package openapi

import (
	"Zadanie2/metastore"
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/google/uuid"
)

func convertTypeToLogical(t metastore.ColumnType) LogicalColumnType {
    switch t {
    case metastore.TypeString:
		return VARCHAR
	case metastore.TypeInt:
		return INT64
	default:
		panic("unknown column type")
	}
}


func convertTypeFromLogical(t LogicalColumnType) (metastore.ColumnType, error) {
    switch t {
    case VARCHAR:
		return metastore.TypeString, nil
	case INT64:
		return metastore.TypeInt, nil
	default:
		return 0, errors.New("unknown column type")
	}
}

func convertColumns(cols []metastore.Column) []Column {
    out := make([]Column, len(cols))
    for i, c := range cols {
        out[i] = Column{
            Name: c.Name,
            Type: convertTypeToLogical(c.Type),
        }
    }
    return out
}


// Proj3APIService is a service that implements the logic for the Proj3APIServicer
// This service should implement the business logic for every endpoint for the Proj3API API.
// Include any external packages or services that will be required by this service.
type Proj3APIService struct {
    ms *metastore.Metastore
    qs *queryStore
	si *SystemInfo
	scheduler *QueryScheduler
}

// NewProj3APIService creates a default api service
func NewProj3APIService(ms *metastore.Metastore) *Proj3APIService {
	qs := newQueryStore()
	dataDir := ms.GetDataDir()
	scheduler := NewQueryScheduler(ms, qs, 4, dataDir)
	scheduler.Start()
	return &Proj3APIService{ms: ms, qs: qs, si: NewSystemInfo("1.0.1", "1", "Krzysztof Å»yndul"), scheduler: scheduler}
}

func (s *Proj3APIService) Shutdown() {
	s.scheduler.Stop()
}



// GetTables - Get list of tables with their accompaning IDs. Use those IDs to get details by calling /table endpoint.
func (s *Proj3APIService) GetTables(ctx context.Context) (ImplResponse, error) {
    tables := s.ms.ListTables()
    shallow := make([]ShallowTable, len(tables))
    for i, t := range tables {
        shallow[i] = ShallowTable{TableId: t.ID, Name: t.Name}
    }
    return Response(http.StatusOK, shallow), nil
}



// GetTableById - Get detailed description of selected table
func (s *Proj3APIService) GetTableById(
	ctx context.Context,
	tableId string,
) (ImplResponse, error) {
    t, err := s.ms.GetTableById(tableId)
    if err != nil {
        return Response(http.StatusNotFound, Error{Message: err.Error()}), nil
    }

	columns := make([]metastore.Column, 0, len(t.Columns))
	for _, col := range t.Columns {
		columns = append(columns, col)
	}

    schema := TableSchema{
        Name:    t.Name,
        Columns: convertColumns(columns),
    }
    return Response(http.StatusOK, schema), nil
}



func (s *Proj3APIService) DeleteTable(ctx context.Context, tableId string) (ImplResponse, error) {
	if _, err := s.ms.GetTableById(tableId); err != nil {
		return Response(http.StatusNotFound, Error{Message: err.Error()}), nil
	}

	iq := internalQuery{
		ID: uuid.NewString(),
		QueryDefinition: QueryQueryDefinition{
			TableName: tableId,
		},
		Status:            CREATED,
		IsResultAvailable: false,
		IsSelect:          false,
		IsDelete:          true,
		Submitted:         time.Now(),
		Started:           nil,
		Finished:          nil,
		Error:             nil,
		ResultRows:        QueryResultInner{},
	}

	s.qs.add(&iq)
	log.Println("Submitting delete table query", iq.string())
	s.scheduler.SubmitQuery(iq.ID)

	// TODO !!! cant just return need to wait for execution
	type DeleteResponse struct {
		Message string `json:"message"`
		QueryID string `json:"queryId"`
	}

	return Response(http.StatusOK, DeleteResponse{
		Message: "Table deletion queued",
		QueryID: iq.ID,
	}), nil
}



// CreateTable - Create new table in database
func (s *Proj3APIService) CreateTable(
	ctx context.Context,
	tableSchema TableSchema,
) (ImplResponse, error) {
    name := tableSchema.Name

    cols := make([]metastore.Column, 0, len(tableSchema.Columns))
    for i, c := range tableSchema.Columns {
        logicalType, err := convertTypeFromLogical(c.Type)
        if err != nil {
            return Response(http.StatusBadRequest, fmt.Sprintf("Invalid column type for column '%s': %v", c.Name, err)), nil
        }
        cols[i] = metastore.Column{
            Name: c.Name,
            Type: logicalType,
        }
    }

	tableID, err := s.ms.CreateTable(name, cols, name)
	if err != nil {
		return Response(http.StatusBadRequest, fmt.Sprintf("failed to create table '%s': %v", name, err)), nil
	}
    return Response(http.StatusOK, tableID), nil
}

//  GetQueries - Get list of queries (optional in project 3, but useful). Use those IDs to get details by calling /query endpoint.
func (s *Proj3APIService) GetQueries(ctx context.Context) (ImplResponse, error) {
    items := s.qs.list()
    out := make([]ShallowQuery, len(items))
    for i, iq := range items {
        out[i] = toShallow(iq)
    }
    return Response(http.StatusOK, out), nil
}


// GetQueryById - Get detailed status of selected query
func (s *Proj3APIService) GetQueryById(
	ctx context.Context,
	queryId string,
) (ImplResponse, error) {
    iq, ok := s.qs.get(queryId)
    if !ok {
        return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
    }
    return Response(http.StatusOK, toPublic(iq)), nil
}


// TODO !!!!
// SubmitQuery - Submit new query for execution
func (s *Proj3APIService) SubmitQuery(
	ctx context.Context,
	executeQueryRequest ExecuteQueryRequest,
) (ImplResponse, error) {

	qd := executeQueryRequest.QueryDefinition

	// Validation:
	// SELECT queries require TableName.
	// LOAD queries require SourceFilepath and DestinationColumns.
	isSelect := qd.TableName != ""
	isLoad := qd.SourceFilepath != "" && len(qd.DestinationColumns) > 0


	// TODO add validation of query 400 Cannot create query due to problems in request (or e.g. table in query doesn't exist)

	if !isSelect && !isLoad {
		return Response(
			http.StatusBadRequest,
			"Invalid query definition: either TableName for SELECT or SourceFilepath and DestinationColumns for LOAD must be provided",
		), nil
	}

	iq := internalQuery{
		ID:                uuid.NewString(),
		QueryDefinition:   qd,
		Status:            CREATED,
		IsResultAvailable: false,
		
		IsSelect:          isSelect,
		IsDelete:          false,

		Submitted:         time.Now(),
		Started:           nil,
		Finished:          nil,
		Error:             nil,
		ResultRows:        QueryResultInner{},
	}

	s.qs.add(&iq)

	s.scheduler.SubmitQuery(iq.ID)

	type QueryCreated struct {
		QueryID string `json:"queryId"`
	}

	return Response(
		http.StatusOK,
		QueryCreated{QueryID: iq.ID},
	), nil
}

// GetQueryResult - Get result of selected query (will be available only for SELECT queries after they are completed)
func (s *Proj3APIService) GetQueryResult(ctx context.Context, queryId string, getQueryResultRequest GetQueryResultRequest) (ImplResponse, error) {
	iq, ok := s.qs.get(queryId)
	if !ok {
		return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
	}

	if !iq.IsSelect {
		return Response(http.StatusBadRequest, Error{Message: "Result of this query is not available"}), nil
	}

	if !iq.IsResultAvailable {
		return Response(http.StatusBadRequest, Error{Message: "Result of this query is not available"}), nil
	}

	return Response(http.StatusOK, iq.ResultRows), nil
}

// GetQueryError - Get error of selected query (will be available only for queries in FAILED state)
func (s *Proj3APIService) GetQueryError(ctx context.Context, queryId string) (ImplResponse, error) {

	iq, ok := s.qs.get(queryId)
	if !ok {
		return Response(http.StatusNotFound, Error{Message: "Couldn't find a query of given ID"}), nil
	}

	if iq.Status != FAILED {
		return Response(http.StatusBadRequest, Error{Message: "Error for this query is not available"}), nil
	}

	return Response(http.StatusOK, iq.Error), nil
}

// GetSystemInfo - Get basic information about the system (e.g. version, uptime, etc.)
func (s *Proj3APIService) GetSystemInfo(ctx context.Context) (ImplResponse, error) {
	sysInfo := s.si


	return Response(http.StatusOK, SystemInformation{
		InterfaceVersion: sysInfo.InterfaceVersion,
		Version:          sysInfo.Version,
		Author:           sysInfo.Author,
		Uptime:           sysInfo.UptimeSeconds(),
	}), nil
}
